/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "Platform_Type.h"
#define RCC_BASE           0x40021000
#define GPIOA_BASE 		   0x40010800
#define RCC_APB2ENR        *(vuint32*)(RCC_BASE+0x18)
#define GPIOA_CRH          *((vuint32*)(GPIOA_BASE+0x04))
#define GPIOA_ODR          *((vuint32*)(GPIOA_BASE+0x0c))
#define RCC_CFGR		   *((vuint32*)(RCC_BASE+0x04))

typedef union {
	vuint32 All_fields;
	struct {
		vuint32 reserved:13;
		vuint32 pin13:1;
		vuint32 pin14:1;
		vuint32 pin15:1;
		vuint32 pin16:1;
		vuint32 pin17:1;
		vuint32 pin18:1;
		vuint32 pin19:1;
		vuint32 pin20:1;
		vuint32 pin21:1;
		vuint32 pin22:1;
		vuint32 pin23:1;
		vuint32 pin24:1;
		vuint32 pin25:1;
		vuint32 pin26:1;
		vuint32 pin27:1;
		vuint32 pin28:1;
		vuint32 pin29:1;
		vuint32 pin30:1;
		vuint32 pin31:1;
	}pins;

}R_ODR;

volatile R_ODR *ODR =  ((volatile R_ODR*)(GPIOA_BASE+0x0c));

void clock_init()
{   //Reset value for RCC_CFGR
	RCC_CFGR = 0x00000000;
	/*Bits 1:0 SW: System clock switch
	Set and cleared by software to select SYSCLK source.
	Set by hardware to force HSI selection when leaving Stop and Standby mode or in case of
	failure of the HSE oscillator used directly or indirectly as system clock (if the Clock Security
	System is enabled).
	00: HSI selected as system clock
	01: HSE selected as system clock
	10: PLL selected as system clock
	11: not allowed*/

	/*Bits 7:4 HPRE: AHB prescaler
	Set and cleared by software to control the division factor of the AHB clock.
	0xxx: SYSCLK not divided
	1000: SYSCLK divided by 2
	1001: SYSCLK divided by 4
	1010: SYSCLK divided by 8
	1011: SYSCLK divided by 16
	1100: SYSCLK divided by 64
	1101: SYSCLK divided by 128
	1110: SYSCLK divided by 256
	1111: SYSCLK divided by 51*/

	/*Bits 10:8 PPRE1: APB low-speed prescaler (APB1)
	Set and cleared by software to control the division factor of the APB low-speed clock
	(PCLK1).
	Warning: the software has to set correctly these bits to not exceed 36 MHz on this domain.
	0xx: HCLK not divided
	100: HCLK divided by 2
	101: HCLK divided by 4
	110: HCLK divided by 8
	111: HCLK divided by 16*/
	RCC_CFGR|= (1<<10);

	/*Bits 13:11 PPRE2: APB high-speed prescaler (APB2)
	Set and cleared by software to control the division factor of the APB high-speed clock
	(PCLK2).
	0xx: HCLK not divided
	100: HCLK divided by 2
	101: HCLK divided by 4
	110: HCLK divided by 8
	111: HCLK divided by 16 */
	RCC_CFGR|=(0b101<<11);



}

int main(void) {
	clock_init();
	//init clock for port A
	RCC_APB2ENR |= 1 << 2;
	//port A init
	GPIOA_CRH &= 0xff0fffff;
	GPIOA_CRH |= 0x00200000;
	int i;
	while (1)
	{

		ODR->pins.pin13=1;
		for (i = 0; i < 5000; i++);
		ODR->pins.pin13=0;
		for (i = 0; i < 5000; i++);
	}

	return 0;
}
